"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SimliClient = void 0;
const events_1 = require("events");
const AudioWorklet_1 = require("./AudioWorklet");
class SimliClient extends events_1.EventEmitter {
    constructor() {
        super();
        this.pc = null;
        this.dc = null;
        this.dcInterval = null;
        this.candidateCount = 0;
        this.prevCandidateCount = -1;
        this.apiKey = "";
        this.faceID = "";
        this.handleSilence = true;
        this.videoRef = null;
        this.audioRef = null;
        this.errorReason = null;
        this.sessionInitialized = false;
        this.inputStreamTrack = null;
        this.sourceNode = null;
        this.audioWorklet = null;
        this.audioBuffer = null;
        this.handleBeforeUnload = (event) => {
            this.close();
            event.preventDefault();
            event.returnValue = "";
        };
        this.handlePageHide = (event) => {
            if (event.persisted) {
                // The page is being cached for bfcache
                this.close();
            }
            else {
                // The page is being unloaded
                this.close();
            }
        };
        if (typeof window !== "undefined") {
            window.addEventListener("beforeunload", this.handleBeforeUnload);
            window.addEventListener("pagehide", this.handlePageHide);
        }
    }
    Initialize(config) {
        this.apiKey = config.apiKey;
        this.faceID = config.faceID;
        this.handleSilence = config.handleSilence;
        if (typeof window !== "undefined") {
            this.videoRef = config.videoRef;
            this.audioRef = config.audioRef;
        }
        else {
            console.warn("Running in Node.js environment. Some features may not be available.");
        }
    }
    createPeerConnection() {
        const config = {
            iceServers: [{ urls: ["stun:stun.l.google.com:19302"] }],
        };
        console.log("Server running: ", config.iceServers);
        this.pc = new window.RTCPeerConnection(config);
        if (this.pc) {
            this.setupPeerConnectionListeners();
        }
    }
    setupPeerConnectionListeners() {
        if (!this.pc)
            return;
        this.pc.addEventListener("icegatheringstatechange", () => {
            var _a;
            console.log("ICE gathering state changed: ", (_a = this.pc) === null || _a === void 0 ? void 0 : _a.iceGatheringState);
        });
        this.pc.addEventListener("iceconnectionstatechange", () => {
            var _a;
            console.log("ICE connection state changed: ", (_a = this.pc) === null || _a === void 0 ? void 0 : _a.iceConnectionState);
        });
        this.pc.addEventListener("signalingstatechange", () => {
            var _a;
            console.log("Signaling state changed: ", (_a = this.pc) === null || _a === void 0 ? void 0 : _a.signalingState);
        });
        this.pc.addEventListener("track", (evt) => {
            var _a, _b;
            console.log("Track event: ", evt.track.kind);
            if (evt.track.kind === "video" && ((_a = this.videoRef) === null || _a === void 0 ? void 0 : _a.current)) {
                this.videoRef.current.srcObject = evt.streams[0];
            }
            else if (evt.track.kind === "audio" && ((_b = this.audioRef) === null || _b === void 0 ? void 0 : _b.current)) {
                this.audioRef.current.srcObject = evt.streams[0];
            }
        });
        this.pc.onicecandidate = (event) => {
            var _a;
            if (event.candidate === null) {
                console.log(JSON.stringify((_a = this.pc) === null || _a === void 0 ? void 0 : _a.localDescription));
            }
            else {
                console.log(event.candidate);
                this.candidateCount += 1;
            }
        };
    }
    async start() {
        var _a, _b;
        await this.createPeerConnection();
        const parameters = { ordered: true };
        this.dc = this.pc.createDataChannel("chat", parameters);
        this.setupDataChannelListeners();
        (_a = this.pc) === null || _a === void 0 ? void 0 : _a.addTransceiver("audio", { direction: "recvonly" });
        (_b = this.pc) === null || _b === void 0 ? void 0 : _b.addTransceiver("video", { direction: "recvonly" });
        await this.negotiate();
    }
    setupDataChannelListeners() {
        if (!this.dc)
            return;
        this.dc.addEventListener("close", () => {
            console.log("Data channel closed");
            this.emit("disconnected");
            this.stopDataChannelInterval();
        });
        this.dc.addEventListener("open", async () => {
            console.log("Data channel opened");
            this.emit("connected");
            await this.initializeSession();
            this.startDataChannelInterval();
        });
        this.dc.addEventListener("message", (evt) => {
            if (evt.data === "START") {
                this.sessionInitialized = true;
            }
            console.log("Received message: ", evt.data);
        });
    }
    startDataChannelInterval() {
        this.stopDataChannelInterval(); // Clear any existing interval
        this.dcInterval = setInterval(() => {
            this.sendPingMessage();
        }, 1000);
    }
    stopDataChannelInterval() {
        if (this.dcInterval) {
            clearInterval(this.dcInterval);
            this.dcInterval = null;
        }
    }
    sendPingMessage() {
        var _a;
        if (this.dc && this.dc.readyState === "open") {
            const message = "ping " + Date.now();
            console.log("Sending: " + message);
            try {
                this.dc.send(message);
            }
            catch (error) {
                console.error("Failed to send message:", error);
                this.stopDataChannelInterval();
            }
        }
        else {
            console.warn("Data channel is not open. Current state:", (_a = this.dc) === null || _a === void 0 ? void 0 : _a.readyState);
            if (this.errorReason !== null) {
                console.error("Error Reason: ", this.errorReason);
            }
            this.stopDataChannelInterval();
        }
    }
    async initializeSession() {
        var _a, _b;
        const metadata = {
            faceId: this.faceID,
            isJPG: false,
            apiKey: this.apiKey,
            syncAudio: true,
            handleSilence: this.handleSilence,
        };
        try {
            const response = await fetch("https://api.simli.ai/startAudioToVideoSession", {
                method: "POST",
                body: JSON.stringify(metadata),
                headers: {
                    "Content-Type": "application/json",
                },
            });
            const resJSON = await response.json();
            if (this.dc && this.dc.readyState === "open") {
                this.dc.send(resJSON.session_token);
            }
            else {
                this.emit("failed");
                this.errorReason = "Session Init failed: Simli API returned Code:" + response.status + "\n" + JSON.stringify(resJSON);
                console.error("Data channel not open when trying to send session token " + this.errorReason);
                await ((_a = this.pc) === null || _a === void 0 ? void 0 : _a.close());
            }
        }
        catch (error) {
            this.emit("failed");
            this.errorReason = "Session Init failed: :" + error;
            console.error("Failed to initialize session:", error);
            await ((_b = this.pc) === null || _b === void 0 ? void 0 : _b.close());
        }
    }
    async negotiate() {
        var _a;
        if (!this.pc) {
            throw new Error("PeerConnection not initialized");
        }
        try {
            const offer = await this.pc.createOffer();
            await this.pc.setLocalDescription(offer);
            await this.waitForIceGathering();
            const localDescription = this.pc.localDescription;
            if (!localDescription)
                return;
            const response = await fetch("https://api.simli.ai/StartWebRTCSession", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    sdp: localDescription.sdp,
                    type: localDescription.type,
                    video_transform: "none",
                }),
            });
            if (response.status !== 200) {
                this.emit("failed");
                const text = await response.text();
                this.errorReason = "Negotiation failed: Simli API returned Code:" + response.status + "\n" + text;
                console.error("Failed to negotiate:", response.status, text);
                (_a = this.pc) === null || _a === void 0 ? void 0 : _a.close();
                return;
            }
            const answer = await response.json();
            await this.pc.setRemoteDescription(new RTCSessionDescription(answer));
        }
        catch (e) {
            console.error("Negotiation failed:", e);
            this.errorReason = "Negotiation failed: " + e;
            this.emit("failed");
            this.pc.close();
        }
    }
    async waitForIceGathering() {
        if (!this.pc)
            return;
        if (this.pc.iceGatheringState === "complete") {
            return;
        }
        return new Promise((resolve) => {
            const checkIceCandidates = () => {
                var _a, _b;
                if (((_a = this.pc) === null || _a === void 0 ? void 0 : _a.iceGatheringState) === "complete" ||
                    this.candidateCount === this.prevCandidateCount) {
                    console.log((_b = this.pc) === null || _b === void 0 ? void 0 : _b.iceGatheringState, this.candidateCount);
                    resolve();
                }
                else {
                    this.prevCandidateCount = this.candidateCount;
                    setTimeout(checkIceCandidates, 250);
                }
            };
            checkIceCandidates();
        });
    }
    listenToMediastreamTrack(stream) {
        this.inputStreamTrack = stream;
        const audioContext = new (window.AudioContext ||
            window.webkitAudioContext)({
            sampleRate: 16000,
        });
        this.initializeAudioWorklet(audioContext, stream);
    }
    initializeAudioWorklet(audioContext, stream) {
        audioContext.audioWorklet.addModule(URL.createObjectURL(new Blob([AudioWorklet_1.AudioProcessor], { type: 'application/javascript' }))).then(() => {
            this.audioWorklet = new AudioWorkletNode(audioContext, 'audio-processor');
            this.sourceNode = audioContext.createMediaStreamSource(new MediaStream([stream]));
            if (this.audioWorklet === null) {
                throw new Error("AudioWorklet not initialized");
            }
            this.sourceNode.connect(this.audioWorklet);
            this.audioWorklet.port.onmessage = (event) => {
                if (event.data.type === "audioData") {
                    this.sendAudioData(new Uint8Array(event.data.data.buffer));
                }
            };
        });
    }
    sendAudioData(audioData) {
        var _a;
        if (this.dc && this.dc.readyState === "open") {
            try {
                if (this.sessionInitialized) {
                    this.dc.send(audioData);
                }
                else {
                    console.log("Data channel open but session is being initialized. Ignoring audio data.");
                }
            }
            catch (error) {
                console.error("Failed to send audio data:", error);
            }
        }
        else {
            console.error("Data channel is not open. Current state:", (_a = this.dc) === null || _a === void 0 ? void 0 : _a.readyState, "Error Reason: ", this.errorReason);
        }
    }
    close() {
        var _a, _b, _c;
        this.emit("disconnected");
        this.stopDataChannelInterval();
        // close data channel
        if (this.dc) {
            this.dc.close();
        }
        // close transceivers
        if ((_a = this.pc) === null || _a === void 0 ? void 0 : _a.getTransceivers) {
            this.pc.getTransceivers().forEach((transceiver) => {
                if (transceiver.stop) {
                    transceiver.stop();
                }
            });
        }
        // close local audio / video
        (_b = this.pc) === null || _b === void 0 ? void 0 : _b.getSenders().forEach((sender) => {
            var _a;
            (_a = sender.track) === null || _a === void 0 ? void 0 : _a.stop();
        });
        // close peer connection
        (_c = this.pc) === null || _c === void 0 ? void 0 : _c.close();
        // Cleanup
        if (typeof window !== "undefined") {
            window.removeEventListener("beforeunload", this.handleBeforeUnload);
            window.removeEventListener("pagehide", this.handlePageHide);
        }
    }
}
exports.SimliClient = SimliClient;
