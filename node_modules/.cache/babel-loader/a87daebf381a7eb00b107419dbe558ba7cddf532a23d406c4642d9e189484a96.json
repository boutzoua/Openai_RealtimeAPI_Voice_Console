{"ast":null,"code":"export const StreamProcessorWorklet = `\nclass StreamProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.hasStarted = false;\n    this.hasInterrupted = false;\n    this.outputBuffers = [];\n    this.bufferLength = 128;\n    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };\n    this.writeOffset = 0;\n    this.trackSampleOffsets = {};\n    this.port.onmessage = (event) => {\n      if (event.data) {\n        const payload = event.data;\n        if (payload.event === 'write') {\n          const int16Array = payload.buffer;\n          const float32Array = new Float32Array(int16Array.length);\n          for (let i = 0; i < int16Array.length; i++) {\n            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32\n          }\n          this.writeData(float32Array, payload.trackId);\n        } else if (\n          payload.event === 'offset' ||\n          payload.event === 'interrupt'\n        ) {\n          const requestId = payload.requestId;\n          const trackId = this.write.trackId;\n          const offset = this.trackSampleOffsets[trackId] || 0;\n          this.port.postMessage({\n            event: 'offset',\n            requestId,\n            trackId,\n            offset,\n          });\n          if (payload.event === 'interrupt') {\n            this.hasInterrupted = true;\n          }\n        } else {\n          throw new Error(\\`Unhandled event \"\\${payload.event}\"\\`);\n        }\n      }\n    };\n  }\n\n  writeData(float32Array, trackId = null) {\n    let { buffer } = this.write;\n    let offset = this.writeOffset;\n    for (let i = 0; i < float32Array.length; i++) {\n      buffer[offset++] = float32Array[i];\n      if (offset >= buffer.length) {\n        this.outputBuffers.push(this.write);\n        this.write = { buffer: new Float32Array(this.bufferLength), trackId };\n        buffer = this.write.buffer;\n        offset = 0;\n      }\n    }\n    this.writeOffset = offset;\n    return true;\n  }\n\n  process(inputs, outputs, parameters) {\n    const output = outputs[0];\n    const outputChannelData = output[0];\n    const outputBuffers = this.outputBuffers;\n    if (this.hasInterrupted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else if (outputBuffers.length) {\n      this.hasStarted = true;\n      const { buffer, trackId } = outputBuffers.shift();\n      for (let i = 0; i < outputChannelData.length; i++) {\n        outputChannelData[i] = buffer[i] || 0;\n      }\n      if (trackId) {\n        this.trackSampleOffsets[trackId] =\n          this.trackSampleOffsets[trackId] || 0;\n        this.trackSampleOffsets[trackId] += buffer.length;\n      }\n      return true;\n    } else if (this.hasStarted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nregisterProcessor('stream_processor', StreamProcessor);\n`;\nconst script = new Blob([StreamProcessorWorklet], {\n  type: 'application/javascript'\n});\nconst src = URL.createObjectURL(script);\nexport const StreamProcessorSrc = src;","map":{"version":3,"names":["StreamProcessorWorklet","script","Blob","type","src","URL","createObjectURL","StreamProcessorSrc"],"sources":["/Users/smartleet/Desktop/Openai_RealtimeAPI_Voice_Console/src/lib/wavtools/lib/worklets/stream_processor.js"],"sourcesContent":["export const StreamProcessorWorklet = `\r\nclass StreamProcessor extends AudioWorkletProcessor {\r\n  constructor() {\r\n    super();\r\n    this.hasStarted = false;\r\n    this.hasInterrupted = false;\r\n    this.outputBuffers = [];\r\n    this.bufferLength = 128;\r\n    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };\r\n    this.writeOffset = 0;\r\n    this.trackSampleOffsets = {};\r\n    this.port.onmessage = (event) => {\r\n      if (event.data) {\r\n        const payload = event.data;\r\n        if (payload.event === 'write') {\r\n          const int16Array = payload.buffer;\r\n          const float32Array = new Float32Array(int16Array.length);\r\n          for (let i = 0; i < int16Array.length; i++) {\r\n            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32\r\n          }\r\n          this.writeData(float32Array, payload.trackId);\r\n        } else if (\r\n          payload.event === 'offset' ||\r\n          payload.event === 'interrupt'\r\n        ) {\r\n          const requestId = payload.requestId;\r\n          const trackId = this.write.trackId;\r\n          const offset = this.trackSampleOffsets[trackId] || 0;\r\n          this.port.postMessage({\r\n            event: 'offset',\r\n            requestId,\r\n            trackId,\r\n            offset,\r\n          });\r\n          if (payload.event === 'interrupt') {\r\n            this.hasInterrupted = true;\r\n          }\r\n        } else {\r\n          throw new Error(\\`Unhandled event \"\\${payload.event}\"\\`);\r\n        }\r\n      }\r\n    };\r\n  }\r\n\r\n  writeData(float32Array, trackId = null) {\r\n    let { buffer } = this.write;\r\n    let offset = this.writeOffset;\r\n    for (let i = 0; i < float32Array.length; i++) {\r\n      buffer[offset++] = float32Array[i];\r\n      if (offset >= buffer.length) {\r\n        this.outputBuffers.push(this.write);\r\n        this.write = { buffer: new Float32Array(this.bufferLength), trackId };\r\n        buffer = this.write.buffer;\r\n        offset = 0;\r\n      }\r\n    }\r\n    this.writeOffset = offset;\r\n    return true;\r\n  }\r\n\r\n  process(inputs, outputs, parameters) {\r\n    const output = outputs[0];\r\n    const outputChannelData = output[0];\r\n    const outputBuffers = this.outputBuffers;\r\n    if (this.hasInterrupted) {\r\n      this.port.postMessage({ event: 'stop' });\r\n      return false;\r\n    } else if (outputBuffers.length) {\r\n      this.hasStarted = true;\r\n      const { buffer, trackId } = outputBuffers.shift();\r\n      for (let i = 0; i < outputChannelData.length; i++) {\r\n        outputChannelData[i] = buffer[i] || 0;\r\n      }\r\n      if (trackId) {\r\n        this.trackSampleOffsets[trackId] =\r\n          this.trackSampleOffsets[trackId] || 0;\r\n        this.trackSampleOffsets[trackId] += buffer.length;\r\n      }\r\n      return true;\r\n    } else if (this.hasStarted) {\r\n      this.port.postMessage({ event: 'stop' });\r\n      return false;\r\n    } else {\r\n      return true;\r\n    }\r\n  }\r\n}\r\n\r\nregisterProcessor('stream_processor', StreamProcessor);\r\n`;\r\n\r\nconst script = new Blob([StreamProcessorWorklet], {\r\n  type: 'application/javascript',\r\n});\r\nconst src = URL.createObjectURL(script);\r\nexport const StreamProcessorSrc = src;\r\n"],"mappings":"AAAA,OAAO,MAAMA,sBAAsB,GAAG;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,MAAM,GAAG,IAAIC,IAAI,CAAC,CAACF,sBAAsB,CAAC,EAAE;EAChDG,IAAI,EAAE;AACR,CAAC,CAAC;AACF,MAAMC,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACL,MAAM,CAAC;AACvC,OAAO,MAAMM,kBAAkB,GAAGH,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}