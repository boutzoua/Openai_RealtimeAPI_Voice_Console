{"ast":null,"code":"const AudioProcessorWorklet = `\nclass AudioProcessor extends AudioWorkletProcessor {\n\n  constructor() {\n    super();\n    this.port.onmessage = this.receive.bind(this);\n    this.initialize();\n  }\n\n  initialize() {\n    this.foundAudio = false;\n    this.recording = false;\n    this.chunks = [];\n  }\n\n  /**\n   * Concatenates sampled chunks into channels\n   * Format is chunk[Left[], Right[]]\n   */\n  readChannelData(chunks, channel = -1, maxChannels = 9) {\n    let channelLimit;\n    if (channel !== -1) {\n      if (chunks[0] && chunks[0].length - 1 < channel) {\n        throw new Error(\n          \\`Channel \\${channel} out of range: max \\${chunks[0].length}\\`\n        );\n      }\n      channelLimit = channel + 1;\n    } else {\n      channel = 0;\n      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);\n    }\n    const channels = [];\n    for (let n = channel; n < channelLimit; n++) {\n      const length = chunks.reduce((sum, chunk) => {\n        return sum + chunk[n].length;\n      }, 0);\n      const buffers = chunks.map((chunk) => chunk[n]);\n      const result = new Float32Array(length);\n      let offset = 0;\n      for (let i = 0; i < buffers.length; i++) {\n        result.set(buffers[i], offset);\n        offset += buffers[i].length;\n      }\n      channels[n] = result;\n    }\n    return channels;\n  }\n\n  /**\n   * Combines parallel audio data into correct format,\n   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]\n   */\n  formatAudioData(channels) {\n    if (channels.length === 1) {\n      // Simple case is only one channel\n      const float32Array = channels[0].slice();\n      const meanValues = channels[0].slice();\n      return { float32Array, meanValues };\n    } else {\n      const float32Array = new Float32Array(\n        channels[0].length * channels.length\n      );\n      const meanValues = new Float32Array(channels[0].length);\n      for (let i = 0; i < channels[0].length; i++) {\n        const offset = i * channels.length;\n        let meanValue = 0;\n        for (let n = 0; n < channels.length; n++) {\n          float32Array[offset + n] = channels[n][i];\n          meanValue += channels[n][i];\n        }\n        meanValues[i] = meanValue / channels.length;\n      }\n      return { float32Array, meanValues };\n    }\n  }\n\n  /**\n   * Converts 32-bit float data to 16-bit integers\n   */\n  floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Retrieves the most recent amplitude values from the audio stream\n   * @param {number} channel\n   */\n  getValues(channel = -1) {\n    const channels = this.readChannelData(this.chunks, channel);\n    const { meanValues } = this.formatAudioData(channels);\n    return { meanValues, channels };\n  }\n\n  /**\n   * Exports chunks as an audio/wav file\n   */\n  export() {\n    const channels = this.readChannelData(this.chunks);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const audioData = this.floatTo16BitPCM(float32Array);\n    return {\n      meanValues: meanValues,\n      audio: {\n        bitsPerSample: 16,\n        channels: channels,\n        data: audioData,\n      },\n    };\n  }\n\n  receive(e) {\n    const { event, id } = e.data;\n    let receiptData = {};\n    switch (event) {\n      case 'start':\n        this.recording = true;\n        break;\n      case 'stop':\n        this.recording = false;\n        break;\n      case 'clear':\n        this.initialize();\n        break;\n      case 'export':\n        receiptData = this.export();\n        break;\n      case 'read':\n        receiptData = this.getValues();\n        break;\n      default:\n        break;\n    }\n    // Always send back receipt\n    this.port.postMessage({ event: 'receipt', id, data: receiptData });\n  }\n\n  sendChunk(chunk) {\n    const channels = this.readChannelData([chunk]);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const rawAudioData = this.floatTo16BitPCM(float32Array);\n    const monoAudioData = this.floatTo16BitPCM(meanValues);\n    this.port.postMessage({\n      event: 'chunk',\n      data: {\n        mono: monoAudioData,\n        raw: rawAudioData,\n      },\n    });\n  }\n\n  process(inputList, outputList, parameters) {\n    // Copy input to output (e.g. speakers)\n    // Note that this creates choppy sounds with Mac products\n    const sourceLimit = Math.min(inputList.length, outputList.length);\n    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {\n      const input = inputList[inputNum];\n      const output = outputList[inputNum];\n      const channelCount = Math.min(input.length, output.length);\n      for (let channelNum = 0; channelNum < channelCount; channelNum++) {\n        input[channelNum].forEach((sample, i) => {\n          output[channelNum][i] = sample;\n        });\n      }\n    }\n    const inputs = inputList[0];\n    // There's latency at the beginning of a stream before recording starts\n    // Make sure we actually receive audio data before we start storing chunks\n    let sliceIndex = 0;\n    if (!this.foundAudio) {\n      for (const channel of inputs) {\n        sliceIndex = 0; // reset for each channel\n        if (this.foundAudio) {\n          break;\n        }\n        if (channel) {\n          for (const value of channel) {\n            if (value !== 0) {\n              // find only one non-zero entry in any channel\n              this.foundAudio = true;\n              break;\n            } else {\n              sliceIndex++;\n            }\n          }\n        }\n      }\n    }\n    if (inputs && inputs[0] && this.foundAudio && this.recording) {\n      // We need to copy the TypedArray, because the \\`process\\`\n      // internals will reuse the same buffer to hold each input\n      const chunk = inputs.map((input) => input.slice(sliceIndex));\n      this.chunks.push(chunk);\n      this.sendChunk(chunk);\n    }\n    return true;\n  }\n}\n\nregisterProcessor('audio_processor', AudioProcessor);\n`;\nconst script = new Blob([AudioProcessorWorklet], {\n  type: 'application/javascript'\n});\nconst src = URL.createObjectURL(script);\nexport const AudioProcessorSrc = src;","map":{"version":3,"names":["AudioProcessorWorklet","script","Blob","type","src","URL","createObjectURL","AudioProcessorSrc"],"sources":["/Users/smartleet/Desktop/Openai_RealtimeAPI_Voice_Console/src/lib/wavtools/lib/worklets/audio_processor.js"],"sourcesContent":["const AudioProcessorWorklet = `\r\nclass AudioProcessor extends AudioWorkletProcessor {\r\n\r\n  constructor() {\r\n    super();\r\n    this.port.onmessage = this.receive.bind(this);\r\n    this.initialize();\r\n  }\r\n\r\n  initialize() {\r\n    this.foundAudio = false;\r\n    this.recording = false;\r\n    this.chunks = [];\r\n  }\r\n\r\n  /**\r\n   * Concatenates sampled chunks into channels\r\n   * Format is chunk[Left[], Right[]]\r\n   */\r\n  readChannelData(chunks, channel = -1, maxChannels = 9) {\r\n    let channelLimit;\r\n    if (channel !== -1) {\r\n      if (chunks[0] && chunks[0].length - 1 < channel) {\r\n        throw new Error(\r\n          \\`Channel \\${channel} out of range: max \\${chunks[0].length}\\`\r\n        );\r\n      }\r\n      channelLimit = channel + 1;\r\n    } else {\r\n      channel = 0;\r\n      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);\r\n    }\r\n    const channels = [];\r\n    for (let n = channel; n < channelLimit; n++) {\r\n      const length = chunks.reduce((sum, chunk) => {\r\n        return sum + chunk[n].length;\r\n      }, 0);\r\n      const buffers = chunks.map((chunk) => chunk[n]);\r\n      const result = new Float32Array(length);\r\n      let offset = 0;\r\n      for (let i = 0; i < buffers.length; i++) {\r\n        result.set(buffers[i], offset);\r\n        offset += buffers[i].length;\r\n      }\r\n      channels[n] = result;\r\n    }\r\n    return channels;\r\n  }\r\n\r\n  /**\r\n   * Combines parallel audio data into correct format,\r\n   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]\r\n   */\r\n  formatAudioData(channels) {\r\n    if (channels.length === 1) {\r\n      // Simple case is only one channel\r\n      const float32Array = channels[0].slice();\r\n      const meanValues = channels[0].slice();\r\n      return { float32Array, meanValues };\r\n    } else {\r\n      const float32Array = new Float32Array(\r\n        channels[0].length * channels.length\r\n      );\r\n      const meanValues = new Float32Array(channels[0].length);\r\n      for (let i = 0; i < channels[0].length; i++) {\r\n        const offset = i * channels.length;\r\n        let meanValue = 0;\r\n        for (let n = 0; n < channels.length; n++) {\r\n          float32Array[offset + n] = channels[n][i];\r\n          meanValue += channels[n][i];\r\n        }\r\n        meanValues[i] = meanValue / channels.length;\r\n      }\r\n      return { float32Array, meanValues };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Converts 32-bit float data to 16-bit integers\r\n   */\r\n  floatTo16BitPCM(float32Array) {\r\n    const buffer = new ArrayBuffer(float32Array.length * 2);\r\n    const view = new DataView(buffer);\r\n    let offset = 0;\r\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\r\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\r\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\r\n    }\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Retrieves the most recent amplitude values from the audio stream\r\n   * @param {number} channel\r\n   */\r\n  getValues(channel = -1) {\r\n    const channels = this.readChannelData(this.chunks, channel);\r\n    const { meanValues } = this.formatAudioData(channels);\r\n    return { meanValues, channels };\r\n  }\r\n\r\n  /**\r\n   * Exports chunks as an audio/wav file\r\n   */\r\n  export() {\r\n    const channels = this.readChannelData(this.chunks);\r\n    const { float32Array, meanValues } = this.formatAudioData(channels);\r\n    const audioData = this.floatTo16BitPCM(float32Array);\r\n    return {\r\n      meanValues: meanValues,\r\n      audio: {\r\n        bitsPerSample: 16,\r\n        channels: channels,\r\n        data: audioData,\r\n      },\r\n    };\r\n  }\r\n\r\n  receive(e) {\r\n    const { event, id } = e.data;\r\n    let receiptData = {};\r\n    switch (event) {\r\n      case 'start':\r\n        this.recording = true;\r\n        break;\r\n      case 'stop':\r\n        this.recording = false;\r\n        break;\r\n      case 'clear':\r\n        this.initialize();\r\n        break;\r\n      case 'export':\r\n        receiptData = this.export();\r\n        break;\r\n      case 'read':\r\n        receiptData = this.getValues();\r\n        break;\r\n      default:\r\n        break;\r\n    }\r\n    // Always send back receipt\r\n    this.port.postMessage({ event: 'receipt', id, data: receiptData });\r\n  }\r\n\r\n  sendChunk(chunk) {\r\n    const channels = this.readChannelData([chunk]);\r\n    const { float32Array, meanValues } = this.formatAudioData(channels);\r\n    const rawAudioData = this.floatTo16BitPCM(float32Array);\r\n    const monoAudioData = this.floatTo16BitPCM(meanValues);\r\n    this.port.postMessage({\r\n      event: 'chunk',\r\n      data: {\r\n        mono: monoAudioData,\r\n        raw: rawAudioData,\r\n      },\r\n    });\r\n  }\r\n\r\n  process(inputList, outputList, parameters) {\r\n    // Copy input to output (e.g. speakers)\r\n    // Note that this creates choppy sounds with Mac products\r\n    const sourceLimit = Math.min(inputList.length, outputList.length);\r\n    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {\r\n      const input = inputList[inputNum];\r\n      const output = outputList[inputNum];\r\n      const channelCount = Math.min(input.length, output.length);\r\n      for (let channelNum = 0; channelNum < channelCount; channelNum++) {\r\n        input[channelNum].forEach((sample, i) => {\r\n          output[channelNum][i] = sample;\r\n        });\r\n      }\r\n    }\r\n    const inputs = inputList[0];\r\n    // There's latency at the beginning of a stream before recording starts\r\n    // Make sure we actually receive audio data before we start storing chunks\r\n    let sliceIndex = 0;\r\n    if (!this.foundAudio) {\r\n      for (const channel of inputs) {\r\n        sliceIndex = 0; // reset for each channel\r\n        if (this.foundAudio) {\r\n          break;\r\n        }\r\n        if (channel) {\r\n          for (const value of channel) {\r\n            if (value !== 0) {\r\n              // find only one non-zero entry in any channel\r\n              this.foundAudio = true;\r\n              break;\r\n            } else {\r\n              sliceIndex++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    if (inputs && inputs[0] && this.foundAudio && this.recording) {\r\n      // We need to copy the TypedArray, because the \\`process\\`\r\n      // internals will reuse the same buffer to hold each input\r\n      const chunk = inputs.map((input) => input.slice(sliceIndex));\r\n      this.chunks.push(chunk);\r\n      this.sendChunk(chunk);\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\nregisterProcessor('audio_processor', AudioProcessor);\r\n`;\r\n\r\nconst script = new Blob([AudioProcessorWorklet], {\r\n  type: 'application/javascript',\r\n});\r\nconst src = URL.createObjectURL(script);\r\nexport const AudioProcessorSrc = src;\r\n"],"mappings":"AAAA,MAAMA,qBAAqB,GAAG;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AAED,MAAMC,MAAM,GAAG,IAAIC,IAAI,CAAC,CAACF,qBAAqB,CAAC,EAAE;EAC/CG,IAAI,EAAE;AACR,CAAC,CAAC;AACF,MAAMC,GAAG,GAAGC,GAAG,CAACC,eAAe,CAACL,MAAM,CAAC;AACvC,OAAO,MAAMM,iBAAiB,GAAGH,GAAG","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}