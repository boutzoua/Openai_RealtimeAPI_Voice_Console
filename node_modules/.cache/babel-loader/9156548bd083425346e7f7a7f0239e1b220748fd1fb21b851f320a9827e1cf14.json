{"ast":null,"code":"import { StreamProcessorSrc } from './worklets/stream_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\n\n/**\r\n * Plays audio streams received in raw PCM16 chunks from the browser\r\n * @class\r\n */\nexport class WavStreamPlayer {\n  /**\r\n   * Creates a new WavStreamPlayer instance\r\n   * @param {{sampleRate?: number}} options\r\n   * @returns {WavStreamPlayer}\r\n   */\n  constructor({\n    sampleRate = 44100\n  } = {}) {\n    this.scriptSrc = StreamProcessorSrc;\n    this.sampleRate = sampleRate;\n    this.context = null;\n    this.stream = null;\n    this.analyser = null;\n    this.trackSampleOffsets = {};\n    this.interruptedTrackIds = {};\n  }\n\n  /**\r\n   * Connects the audio context and enables output to speakers\r\n   * @returns {Promise<true>}\r\n   */\n  async connect() {\n    this.context = new AudioContext({\n      sampleRate: this.sampleRate\n    });\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    try {\n      await this.context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const analyser = this.context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    this.analyser = analyser;\n    return true;\n  }\n\n  /**\r\n   * Gets the current frequency domain data from the playing track\r\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\r\n   * @param {number} [minDecibels] default -100\r\n   * @param {number} [maxDecibels] default -30\r\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\r\n   */\n  getFrequencies(analysisType = 'frequency', minDecibels = -100, maxDecibels = -30) {\n    if (!this.analyser) {\n      throw new Error('Not connected, please call .connect() first');\n    }\n    return AudioAnalysis.getFrequencies(this.analyser, this.sampleRate, null, analysisType, minDecibels, maxDecibels);\n  }\n\n  /**\r\n   * Starts audio streaming\r\n   * @private\r\n   * @returns {Promise<true>}\r\n   */\n  _start() {\n    const streamNode = new AudioWorkletNode(this.context, 'stream_processor');\n    streamNode.connect(this.context.destination);\n    streamNode.port.onmessage = e => {\n      const {\n        event\n      } = e.data;\n      if (event === 'stop') {\n        streamNode.disconnect();\n        this.stream = null;\n      } else if (event === 'offset') {\n        const {\n          requestId,\n          trackId,\n          offset\n        } = e.data;\n        const currentTime = offset / this.sampleRate;\n        this.trackSampleOffsets[requestId] = {\n          trackId,\n          offset,\n          currentTime\n        };\n      }\n    };\n    this.analyser.disconnect();\n    streamNode.connect(this.analyser);\n    this.stream = streamNode;\n    return true;\n  }\n\n  /**\r\n   * Adds 16BitPCM data to the currently playing audio stream\r\n   * You can add chunks beyond the current play point and they will be queued for play\r\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\r\n   * @param {string} [trackId]\r\n   * @returns {Int16Array}\r\n   */\n  add16BitPCM(arrayBuffer, trackId = 'default') {\n    if (typeof trackId !== 'string') {\n      throw new Error(`trackId must be a string`);\n    } else if (this.interruptedTrackIds[trackId]) {\n      return;\n    }\n    if (!this.stream) {\n      this._start();\n    }\n    let buffer;\n    if (arrayBuffer instanceof Int16Array) {\n      buffer = arrayBuffer;\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      buffer = new Int16Array(arrayBuffer);\n    } else {\n      throw new Error(`argument must be Int16Array or ArrayBuffer`);\n    }\n    this.stream.port.postMessage({\n      event: 'write',\n      buffer,\n      trackId\n    });\n    return buffer;\n  }\n\n  /**\r\n   * Gets the offset (sample count) of the currently playing stream\r\n   * @param {boolean} [interrupt]\r\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\r\n   */\n  async getTrackSampleOffset(interrupt = false) {\n    if (!this.stream) {\n      return null;\n    }\n    const requestId = crypto.randomUUID();\n    this.stream.port.postMessage({\n      event: interrupt ? 'interrupt' : 'offset',\n      requestId\n    });\n    let trackSampleOffset;\n    while (!trackSampleOffset) {\n      trackSampleOffset = this.trackSampleOffsets[requestId];\n      await new Promise(r => setTimeout(() => r(), 1));\n    }\n    const {\n      trackId\n    } = trackSampleOffset;\n    if (interrupt && trackId) {\n      this.interruptedTrackIds[trackId] = true;\n    }\n    return trackSampleOffset;\n  }\n\n  /**\r\n   * Strips the current stream and returns the sample offset of the audio\r\n   * @param {boolean} [interrupt]\r\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\r\n   */\n  async interrupt() {\n    return this.getTrackSampleOffset(true);\n  }\n}\nglobalThis.WavStreamPlayer = WavStreamPlayer;","map":{"version":3,"names":["StreamProcessorSrc","AudioAnalysis","WavStreamPlayer","constructor","sampleRate","scriptSrc","context","stream","analyser","trackSampleOffsets","interruptedTrackIds","connect","AudioContext","state","resume","audioWorklet","addModule","e","console","error","Error","createAnalyser","fftSize","smoothingTimeConstant","getFrequencies","analysisType","minDecibels","maxDecibels","_start","streamNode","AudioWorkletNode","destination","port","onmessage","event","data","disconnect","requestId","trackId","offset","currentTime","add16BitPCM","arrayBuffer","buffer","Int16Array","ArrayBuffer","postMessage","getTrackSampleOffset","interrupt","crypto","randomUUID","trackSampleOffset","Promise","r","setTimeout","globalThis"],"sources":["/Users/smartleet/Desktop/Openai_RealtimeAPI_Voice_Console/src/lib/wavtools/lib/wav_stream_player.js"],"sourcesContent":["import { StreamProcessorSrc } from './worklets/stream_processor.js';\r\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\r\n\r\n/**\r\n * Plays audio streams received in raw PCM16 chunks from the browser\r\n * @class\r\n */\r\nexport class WavStreamPlayer {\r\n  /**\r\n   * Creates a new WavStreamPlayer instance\r\n   * @param {{sampleRate?: number}} options\r\n   * @returns {WavStreamPlayer}\r\n   */\r\n  constructor({ sampleRate = 44100 } = {}) {\r\n    this.scriptSrc = StreamProcessorSrc;\r\n    this.sampleRate = sampleRate;\r\n    this.context = null;\r\n    this.stream = null;\r\n    this.analyser = null;\r\n    this.trackSampleOffsets = {};\r\n    this.interruptedTrackIds = {};\r\n  }\r\n\r\n  /**\r\n   * Connects the audio context and enables output to speakers\r\n   * @returns {Promise<true>}\r\n   */\r\n  async connect() {\r\n    this.context = new AudioContext({ sampleRate: this.sampleRate });\r\n    if (this.context.state === 'suspended') {\r\n      await this.context.resume();\r\n    }\r\n    try {\r\n      await this.context.audioWorklet.addModule(this.scriptSrc);\r\n    } catch (e) {\r\n      console.error(e);\r\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\r\n    }\r\n    const analyser = this.context.createAnalyser();\r\n    analyser.fftSize = 8192;\r\n    analyser.smoothingTimeConstant = 0.1;\r\n    this.analyser = analyser;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Gets the current frequency domain data from the playing track\r\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\r\n   * @param {number} [minDecibels] default -100\r\n   * @param {number} [maxDecibels] default -30\r\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\r\n   */\r\n  getFrequencies(\r\n    analysisType = 'frequency',\r\n    minDecibels = -100,\r\n    maxDecibels = -30\r\n  ) {\r\n    if (!this.analyser) {\r\n      throw new Error('Not connected, please call .connect() first');\r\n    }\r\n    return AudioAnalysis.getFrequencies(\r\n      this.analyser,\r\n      this.sampleRate,\r\n      null,\r\n      analysisType,\r\n      minDecibels,\r\n      maxDecibels\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Starts audio streaming\r\n   * @private\r\n   * @returns {Promise<true>}\r\n   */\r\n  _start() {\r\n    const streamNode = new AudioWorkletNode(this.context, 'stream_processor');\r\n    streamNode.connect(this.context.destination);\r\n    streamNode.port.onmessage = (e) => {\r\n      const { event } = e.data;\r\n      if (event === 'stop') {\r\n        streamNode.disconnect();\r\n        this.stream = null;\r\n      } else if (event === 'offset') {\r\n        const { requestId, trackId, offset } = e.data;\r\n        const currentTime = offset / this.sampleRate;\r\n        this.trackSampleOffsets[requestId] = { trackId, offset, currentTime };\r\n      }\r\n    };\r\n    this.analyser.disconnect();\r\n    streamNode.connect(this.analyser);\r\n    this.stream = streamNode;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Adds 16BitPCM data to the currently playing audio stream\r\n   * You can add chunks beyond the current play point and they will be queued for play\r\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\r\n   * @param {string} [trackId]\r\n   * @returns {Int16Array}\r\n   */\r\n  add16BitPCM(arrayBuffer, trackId = 'default') {\r\n    if (typeof trackId !== 'string') {\r\n      throw new Error(`trackId must be a string`);\r\n    } else if (this.interruptedTrackIds[trackId]) {\r\n      return;\r\n    }\r\n    if (!this.stream) {\r\n      this._start();\r\n    }\r\n    let buffer;\r\n    if (arrayBuffer instanceof Int16Array) {\r\n      buffer = arrayBuffer;\r\n    } else if (arrayBuffer instanceof ArrayBuffer) {\r\n      buffer = new Int16Array(arrayBuffer);\r\n    } else {\r\n      throw new Error(`argument must be Int16Array or ArrayBuffer`);\r\n    }\r\n    this.stream.port.postMessage({ event: 'write', buffer, trackId });\r\n    return buffer;\r\n  }\r\n\r\n  /**\r\n   * Gets the offset (sample count) of the currently playing stream\r\n   * @param {boolean} [interrupt]\r\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\r\n   */\r\n  async getTrackSampleOffset(interrupt = false) {\r\n    if (!this.stream) {\r\n      return null;\r\n    }\r\n    const requestId = crypto.randomUUID();\r\n    this.stream.port.postMessage({\r\n      event: interrupt ? 'interrupt' : 'offset',\r\n      requestId,\r\n    });\r\n    let trackSampleOffset;\r\n    while (!trackSampleOffset) {\r\n      trackSampleOffset = this.trackSampleOffsets[requestId];\r\n      await new Promise((r) => setTimeout(() => r(), 1));\r\n    }\r\n    const { trackId } = trackSampleOffset;\r\n    if (interrupt && trackId) {\r\n      this.interruptedTrackIds[trackId] = true;\r\n    }\r\n    return trackSampleOffset;\r\n  }\r\n\r\n  /**\r\n   * Strips the current stream and returns the sample offset of the audio\r\n   * @param {boolean} [interrupt]\r\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\r\n   */\r\n  async interrupt() {\r\n    return this.getTrackSampleOffset(true);\r\n  }\r\n}\r\n\r\nglobalThis.WavStreamPlayer = WavStreamPlayer;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}